//@@Chess@@

// Possible pieces on the chess board
enum{K, Q, R, N, B, P}; //king, queen, rook, knight, bishop, pawn
var SCOREMAP = [0, 9, 5, 3, 3, 1]; //mapped to k, q, r, n, b, p. King: 0, Queen: 9, Rook: 5, Bishop: 3, Knight: 3, Pawn: 1
enum{CARLSEN, DING, DRAW, LESS_THAN_5, NO_PLAYER}; //turn
enum{WINNING_CARLSEN, WINNING_DING, WINNING_NEUTRAL}; // Winning State

// Constants
var PIECE_TYPES = [K, Q, R, N, B, P];
var PIECE_TYPE_COUNT = 6;

// Start of Input Section
var carlsen_pieces = [K, P];
var num_carlsen_pieces = 2;

var ding_pieces = [K, P, B];
var num_ding_pieces = 3;

var num_pieces = num_carlsen_pieces + num_ding_pieces;
// End of Input Section

var carlsen_score = 0;
var ding_score = 0;
var next_turn = NO_PLAYER; // No turn assigned, this will be set in the init function
var winning = WINNING_NEUTRAL; // Neutral Board, this will be set in the init function
var won = NO_PLAYER;

// Limiter for guaranteed end
// Note that there is a 50-move tie rule in Chess, but for now it is limited to only 10
var TURN_LIMIT = 7;
var turn_count = 0;

// Probabilities of moving a piece
// Suppose P = MOVE_PROBS[x][y][z][w]
// P is the probability of moving piece PIECE_TYPES[w] given winning state STATE[z] for PLAYER[y] when there are x + 5 pieces on the board
var move_probs[2][2][3][6] = [
	// 5 moves
	
	// Carlsen 5
 // k, q, r, n, b, p
	3, 3, 3, 3, 3, 3, // Winning
	1, 3, 3, 3, 3, 3, // Losing
	3, 3, 1, 3, 3, 3, // Neutral
	
	// Ding 5
	3, 3, 3, 3, 3, 3,
	1, 3, 3, 3, 3, 3,
	3, 3, 1, 3, 3, 3,
	
	// 6 moves
	
	// Carlsen 6
	3, 3, 3, 3, 3, 3,
	1, 3, 3, 3, 3, 3,
	3, 3, 1, 3, 3, 3,
	
	
	// Ding 6
	3, 3, 3, 3, 3, 3,
	1, 3, 3, 3, 3, 3,
	3, 3, 1, 3, 3, 3
];

var prob_to_capture = [1, 1, 1, 1, 1, 1]; // If opp piece does not exist, set to 0

EliminateMoveProbs(num_board_pieces, player) = eliminateMoveProbs.player{
	var type_index = 0;
	
	var num_player_pieces;
	var player_pieces_arr;
	if (player == CARLSEN) {
		num_player_pieces = num_carlsen_pieces;
		player_pieces_arr = carlsen_pieces;

	} else if (player == DING) {
		num_player_pieces = num_ding_pieces;
		player_pieces_arr = ding_pieces;

	} else {
		type_index = 6; // We make it not run at all
	};
	
	while (type_index < 6) {
		var target_piece_type = PIECE_TYPES[type_index];
		var has_piece = false;
		var player_piece_index = 0;

		while (player_piece_index < num_player_pieces) {
			var player_piece = player_pieces_arr[player_piece_index];

			if (player_piece == target_piece_type) {
				has_piece = true;
				player_piece_index = num_player_pieces; //Effectively a break
			};

			player_piece_index = player_piece_index + 1;
		};

		if (!has_piece) {
			var array_piece_count_index = num_board_pieces - 5;
			move_probs[array_piece_count_index][player][0][target_piece_type] = 0;
			move_probs[array_piece_count_index][player][1][target_piece_type] = 0;
			move_probs[array_piece_count_index][player][2][target_piece_type] = 0;
		};

		type_index = type_index + 1;
	};
} -> Skip;

EndTurn = CalcCarlsenScore;CalcDingScore;UpdateWinning;Turn;

CalcCarlsenScore = calcCarlsenScore{
	carlsen_score = 0;
	
	var index = 0;
	while (index < num_carlsen_pieces) {
		carlsen_score = carlsen_score + SCOREMAP[carlsen_pieces[index]];
	index = index + 1;
	};
} -> Skip;

CalcDingScore = calcDingScore{
	ding_score = 0;
	
	var index = 0;
	while (index < num_ding_pieces) {
		ding_score = ding_score + SCOREMAP[ding_pieces[index]];
		index = index + 1;
	};
} -> Skip;

UpdateWinning = updateWinning{
	if (carlsen_score > ding_score) {
		winning = WINNING_CARLSEN;
	} else if (carlsen_score < ding_score) {
		winning = WINNING_DING;
	} else {
		winning = WINNING_NEUTRAL;
	}	
} -> Skip;

SelectStartingPlayer = []i:{CARLSEN, DING}@ selectStartingPlayer{next_turn = i} -> Skip; //Randomised start
Game = SelectStartingPlayer; EliminateMoveProbs(num_pieces, CARLSEN); EliminateMoveProbs(num_pieces, DING); Turn;

Turn = [turn_count <= TURN_LIMIT && won == NO_PLAYER && next_turn == CARLSEN]{next_turn=DING; turn_count++} -> CarlsenMove
    []
       [turn_count <= TURN_LIMIT && won == NO_PLAYER && next_turn == DING]{next_turn=CARLSEN; turn_count++} -> DingMove
    []
       [won != NO_PLAYER || turn_count > TURN_LIMIT] GameOver -> Skip
    ;

CarlsenMove = [won == NO_PLAYER && num_pieces == 5 && winning == WINNING_CARLSEN]CarlsenWinning5 -> Carlsen_Winning5Move
  []
[won == NO_PLAYER && num_pieces == 5 && winning == WINNING_DING]CarlsenLosing5 -> Carlsen_Losing5Move
  [] 
[won == NO_PLAYER && num_pieces == 5 && winning == WINNING_NEUTRAL]CarlsenNeutral5 -> Carlsen_Neutral5Move;

DingMove = [won == NO_PLAYER && num_pieces == 5 && winning == WINNING_DING]DingWinning5 -> Ding_Winning5Move
  [] 
[won == NO_PLAYER && num_pieces == 5 && winning == WINNING_CARLSEN]DingLosing5 -> Ding_Losing5Move
  [] 
[won == NO_PLAYER && num_pieces == 5 && winning == WINNING_NEUTRAL]DingNeutral5 -> Ding_Neutral5Move;

// TODO: Complete modelling for num_pieces > 5 and DingMove

#define CarlsenWin won == CARLSEN;
#assert Game reaches CarlsenWin with prob;

#define DingWin won == DING;
#assert Game reaches DingWin with prob;

#define LessThan5 won == LESS_THAN_5;
#assert Game reaches LessThan5 with prob;

#define Draw won == DRAW;
#assert Game reaches Draw with prob;

#define TurnLimitReached won == NO_PLAYER && turn_count > TURN_LIMIT;
#assert Game reaches TurnLimitReached with prob;

advance(i) = EndTurn;
capture(i) = setCapture.i{won = LESS_THAN_5} -> EndTurn;
endWin(i) = setWinner.i{won = i} -> EndTurn;
endLose(i) = setLoser.i{
	if (i == DING) {
	  won = CARLSEN
	} else if (i == CARLSEN) {
	  won = DING
	};
} -> EndTurn;
endDraw(i) = setDraw.i{won = DRAW} -> EndTurn;

//////////////////////////////////////// CARLSEN START ////////////////////////////////////////////

Carlsen_Winning5K = pcase {
	1:advance(CARLSEN)
	1:capture(CARLSEN) //This will end the game, so won't model 4 or less pieces (too few data)
	1:endWin(CARLSEN) //Checkmate/Opp forfeit
	1:endLose(CARLSEN) //Self forfeit
	1:endDraw(CARLSEN) //Declare Draw
};

Carlsen_Winning5Q = pcase {
	1:advance(CARLSEN)
	1:capture(CARLSEN) //This will end the game, so won't model 4 or less pieces (too few data)
	1:endWin(CARLSEN) //Checkmate/Opp forfeit
	1:endLose(CARLSEN) //Self forfeit
	1:endDraw(CARLSEN) //Declare Draw
};

Carlsen_Winning5R = pcase {
	1:advance(CARLSEN)
	1:capture(CARLSEN) //This will end the game, so won't model 4 or less pieces (too few data)
	1:endWin(CARLSEN) //Checkmate/Opp forfeit
	1:endLose(CARLSEN) //Self forfeit
	1:endDraw(CARLSEN) //Declare Draw
};

Carlsen_Winning5N = pcase {
	1:advance(CARLSEN)
	1:capture(CARLSEN) //This will end the game, so won't model 4 or less pieces (too few data)
	1:endWin(CARLSEN) //Checkmate/Opp forfeit
	1:endLose(CARLSEN) //Self forfeit
	1:endDraw(CARLSEN) //Declare Draw
};

Carlsen_Winning5B = pcase {
	1:advance(CARLSEN)
	1:capture(CARLSEN) //This will end the game, so won't model 4 or less pieces (too few data)
	1:endWin(CARLSEN) //Checkmate/Opp forfeit
	1:endLose(CARLSEN) //Self forfeit
	1:endDraw(CARLSEN) //Declare Draw
};

Carlsen_Winning5P = pcase {
	1:advance(CARLSEN)
	1:capture(CARLSEN) //This will end the game, so won't model 4 or less pieces (too few data)
	1:endWin(CARLSEN) //Checkmate/Opp forfeit
	1:endLose(CARLSEN) //Self forfeit
	1:endDraw(CARLSEN) //Declare Draw
};

Carlsen_Losing5K = pcase {
	1:advance(CARLSEN)
	1:capture(CARLSEN) //This will end the game, so won't model 4 or less pieces (too few data)
	1:endWin(CARLSEN) //Checkmate/Opp forfeit
	1:endLose(CARLSEN) //Self forfeit
	1:endDraw(CARLSEN) //Declare Draw
};

Carlsen_Losing5Q = pcase {
	1:advance(CARLSEN)
	1:capture(CARLSEN) //This will end the game, so won't model 4 or less pieces (too few data)
	1:endWin(CARLSEN) //Checkmate/Opp forfeit
	1:endLose(CARLSEN) //Self forfeit
	1:endDraw(CARLSEN) //Declare Draw
};

Carlsen_Losing5R = pcase {
	1:advance(CARLSEN)
	1:capture(CARLSEN) //This will end the game, so won't model 4 or less pieces (too few data)
	1:endWin(CARLSEN) //Checkmate/Opp forfeit
	1:endLose(CARLSEN) //Self forfeit
	1:endDraw(CARLSEN) //Declare Draw
};

Carlsen_Losing5N = pcase {
	1:advance(CARLSEN)
	1:capture(CARLSEN) //This will end the game, so won't model 4 or less pieces (too few data)
	1:endWin(CARLSEN) //Checkmate/Opp forfeit
	1:endLose(CARLSEN) //Self forfeit
	1:endDraw(CARLSEN) //Declare Draw
};

Carlsen_Losing5B = pcase {
	1:advance(CARLSEN)
	1:capture(CARLSEN) //This will end the game, so won't model 4 or less pieces (too few data)
	1:endWin(CARLSEN) //Checkmate/Opp forfeit
	1:endLose(CARLSEN) //Self forfeit
	1:endDraw(CARLSEN) //Declare Draw
};

Carlsen_Losing5P = pcase {
	1:advance(CARLSEN)
	1:capture(CARLSEN) //This will end the game, so won't model 4 or less pieces (too few data)
	1:endWin(CARLSEN) //Checkmate/Opp forfeit
	1:endLose(CARLSEN) //Self forfeit
	1:endDraw(CARLSEN) //Declare Draw
};

Carlsen_Neutral5K = pcase {
	1:advance(CARLSEN)
	1:capture(CARLSEN) //This will end the game, so won't model 4 or less pieces (too few data)
	1:endWin(CARLSEN) //Checkmate/Opp forfeit
	1:endLose(CARLSEN) //Self forfeit
	1:endDraw(CARLSEN) //Declare Draw
};

Carlsen_Neutral5Q = pcase {
	1:advance(CARLSEN)
	1:capture(CARLSEN) //This will end the game, so won't model 4 or less pieces (too few data)
	1:endWin(CARLSEN) //Checkmate/Opp forfeit
	1:endLose(CARLSEN) //Self forfeit
	1:endDraw(CARLSEN) //Declare Draw
};

Carlsen_Neutral5R = pcase {
	1:advance(CARLSEN)
	1:capture(CARLSEN) //This will end the game, so won't model 4 or less pieces (too few data)
	1:endWin(CARLSEN) //Checkmate/Opp forfeit
	1:endLose(CARLSEN) //Self forfeit
	1:endDraw(CARLSEN) //Declare Draw
};

Carlsen_Neutral5N = pcase {
	1:advance(CARLSEN)
	1:capture(CARLSEN) //This will end the game, so won't model 4 or less pieces (too few data)
	1:endWin(CARLSEN) //Checkmate/Opp forfeit
	1:endLose(CARLSEN) //Self forfeit
	1:endDraw(CARLSEN) //Declare Draw
};

Carlsen_Neutral5B = pcase {
	1:advance(CARLSEN)
	1:capture(CARLSEN) //This will end the game, so won't model 4 or less pieces (too few data)
	1:endWin(CARLSEN) //Checkmate/Opp forfeit
	1:endLose(CARLSEN) //Self forfeit
	1:endDraw(CARLSEN) //Declare Draw
};

Carlsen_Neutral5P = pcase {
	1:advance(CARLSEN)
	1:capture(CARLSEN) //This will end the game, so won't model 4 or less pieces (too few data)
	1:endWin(CARLSEN) //Checkmate/Opp forfeit
	1:endLose(CARLSEN) //Self forfeit
	1:endDraw(CARLSEN) //Declare Draw
};


Carlsen_Winning5Move = pcase {
	move_probs[0][CARLSEN][0][0]: MoveK -> Carlsen_Winning5K  
	move_probs[0][CARLSEN][0][1]: MoveQ -> Carlsen_Winning5Q
	move_probs[0][CARLSEN][0][2]: MoveR -> Carlsen_Winning5R
	move_probs[0][CARLSEN][0][3]: MoveN -> Carlsen_Winning5N
	move_probs[0][CARLSEN][0][4]: MoveB -> Carlsen_Winning5B
	move_probs[0][CARLSEN][0][5]: MoveP -> Carlsen_Winning5P
};

Carlsen_Losing5Move = pcase {
	3: MoveK -> Carlsen_Losing5K  
	3: MoveQ -> Carlsen_Losing5Q
	3: MoveR -> Carlsen_Losing5R
	3: MoveN -> Carlsen_Losing5N
	3: MoveB -> Carlsen_Losing5B
	3: MoveP -> Carlsen_Losing5P  
};

Carlsen_Neutral5Move = pcase {
	3: MoveK -> Carlsen_Neutral5K  
	3: MoveQ -> Carlsen_Neutral5Q
	3: MoveR -> Carlsen_Neutral5R
	3: MoveN -> Carlsen_Neutral5N
	3: MoveB -> Carlsen_Neutral5B
	3: MoveP -> Carlsen_Neutral5P
};

//////////////////////////////////////////// DING START //////////////////////////////////////

Ding_Winning5K = pcase {
	1:advance(DING)
	1:capture(DING) //This will end the game, so won't model 4 or less pieces (too few data)
	1:endWin(DING) //Checkmate/Opp forfeit
	1:endLose(DING) //Self forfeit
	1:endDraw(DING) //Declare Draw
};

Ding_Winning5Q = pcase {
	1:advance(DING)
	1:capture(DING) //This will end the game, so won't model 4 or less pieces (too few data)
	1:endWin(DING) //Checkmate/Opp forfeit
	1:endLose(DING) //Self forfeit
	1:endDraw(DING) //Declare Draw
};

Ding_Winning5R = pcase {
	1:advance(DING)
	1:capture(DING) //This will end the game, so won't model 4 or less pieces (too few data)
	1:endWin(DING) //Checkmate/Opp forfeit
	1:endLose(DING) //Self forfeit
	1:endDraw(DING) //Declare Draw
};

Ding_Winning5N = pcase {
	1:advance(DING)
	1:capture(DING) //This will end the game, so won't model 4 or less pieces (too few data)
	1:endWin(DING) //Checkmate/Opp forfeit
	1:endLose(DING) //Self forfeit
	1:endDraw(DING) //Declare Draw
};

Ding_Winning5B = pcase {
	1:advance(DING)
	1:capture(DING) //This will end the game, so won't model 4 or less pieces (too few data)
	1:endWin(DING) //Checkmate/Opp forfeit
	1:endLose(DING) //Self forfeit
	1:endDraw(DING) //Declare Draw
};

Ding_Winning5P = pcase {
	1:advance(DING)
	1:capture(DING) //This will end the game, so won't model 4 or less pieces (too few data)
	1:endWin(DING) //Checkmate/Opp forfeit
	1:endLose(DING) //Self forfeit
	1:endDraw(DING) //Declare Draw
};

Ding_Losing5K = pcase {
	1:advance(DING)
	1:capture(DING) //This will end the game, so won't model 4 or less pieces (too few data)
	1:endWin(DING) //Checkmate/Opp forfeit
	1:endLose(DING) //Self forfeit
	1:endDraw(DING) //Declare Draw
};

Ding_Losing5Q = pcase {
	1:advance(DING)
	1:capture(DING) //This will end the game, so won't model 4 or less pieces (too few data)
	1:endWin(DING) //Checkmate/Opp forfeit
	1:endLose(DING) //Self forfeit
	1:endDraw(DING) //Declare Draw
};

Ding_Losing5R = pcase {
	1:advance(DING)
	1:capture(DING) //This will end the game, so won't model 4 or less pieces (too few data)
	1:endWin(DING) //Checkmate/Opp forfeit
	1:endLose(DING) //Self forfeit
	1:endDraw(DING) //Declare Draw
};

Ding_Losing5N = pcase {
	1:advance(DING)
	1:capture(DING) //This will end the game, so won't model 4 or less pieces (too few data)
	1:endWin(DING) //Checkmate/Opp forfeit
	1:endLose(DING) //Self forfeit
	1:endDraw(DING) //Declare Draw
};

Ding_Losing5B = pcase {
	1:advance(DING)
	1:capture(DING) //This will end the game, so won't model 4 or less pieces (too few data)
	1:endWin(DING) //Checkmate/Opp forfeit
	1:endLose(DING) //Self forfeit
	1:endDraw(DING) //Declare Draw
};

Ding_Losing5P = pcase {
	1:advance(DING)
	1:capture(DING) //This will end the game, so won't model 4 or less pieces (too few data)
	1:endWin(DING) //Checkmate/Opp forfeit
	1:endLose(DING) //Self forfeit
	1:endDraw(DING) //Declare Draw
};

Ding_Neutral5K = pcase {
	1:advance(DING)
	1:capture(DING) //This will end the game, so won't model 4 or less pieces (too few data)
	1:endWin(DING) //Checkmate/Opp forfeit
	1:endLose(DING) //Self forfeit
	1:endDraw(DING) //Declare Draw
};

Ding_Neutral5Q = pcase {
	1:advance(DING)
	1:capture(DING) //This will end the game, so won't model 4 or less pieces (too few data)
	1:endWin(DING) //Checkmate/Opp forfeit
	1:endLose(DING) //Self forfeit
	1:endDraw(DING) //Declare Draw
};

Ding_Neutral5R = pcase {
	1:advance(DING)
	1:capture(DING) //This will end the game, so won't model 4 or less pieces (too few data)
	1:endWin(DING) //Checkmate/Opp forfeit
	1:endLose(DING) //Self forfeit
	1:endDraw(DING) //Declare Draw
};

Ding_Neutral5N = pcase {
	1:advance(DING)
	1:capture(DING) //This will end the game, so won't model 4 or less pieces (too few data)
	1:endWin(DING) //Checkmate/Opp forfeit
	1:endLose(DING) //Self forfeit
	1:endDraw(DING) //Declare Draw
};

Ding_Neutral5B = pcase {
	1:advance(DING)
	1:capture(DING) //This will end the game, so won't model 4 or less pieces (too few data)
	1:endWin(DING) //Checkmate/Opp forfeit
	1:endLose(DING) //Self forfeit
	1:endDraw(DING) //Declare Draw
};

Ding_Neutral5P = pcase {
	1:advance(DING)
	1:capture(DING) //This will end the game, so won't model 4 or less pieces (too few data)
	1:endWin(DING) //Checkmate/Opp forfeit
	1:endLose(DING) //Self forfeit
	1:endDraw(DING) //Declare Draw
};

Ding_Winning5Move = pcase {
	3: MoveK -> Ding_Winning5K
	3: MoveQ -> Ding_Winning5Q  
	3: MoveR -> Ding_Winning5R  
	3: MoveN -> Ding_Winning5N  
	3: MoveB -> Ding_Winning5B  
	3: MoveP -> Ding_Winning5P  
};

Ding_Losing5Move = pcase {
	3: MoveK -> Ding_Losing5K
	3: MoveQ -> Ding_Losing5Q  
	3: MoveR -> Ding_Losing5R  
	3: MoveN -> Ding_Losing5N  
	3: MoveB -> Ding_Losing5B  
	3: MoveP -> Ding_Losing5P
};

Ding_Neutral5Move = pcase {
	3: MoveK -> Ding_Neutral5K
	3: MoveQ -> Ding_Neutral5Q  
	3: MoveR -> Ding_Neutral5R  
	3: MoveN -> Ding_Neutral5N  
	3: MoveB -> Ding_Neutral5B  
	3: MoveP -> Ding_Neutral5P
};
// End Placeholder

// TODO: Model the rest of the pcases (many many)
